<img 
  width="1500px"
 height="460px"
 src="./images/header_rust_compiler2.jpg"
/>


# üçä Rust Compiler For Dummies


## Setting Up the stage: 
As you may already know, all programs that are written are ultimately converted into binary instructions (those fancy zeros and ones). Why? Because the CPU cannot understand our source code; all it understands is 0s and 1s. Since we cannot write or interact with the memory by writing 0's and 1's we have to created a some abstraction for writing the programmes in human readable fashion.

The thinnest abstraction layer for writing code to interact with memory is **Assembly**. It is a low-level language that helps us write human-readable code, operates directly with memory, and provides fine-grained control over computer operations.
Although Assembly offers high efficiency and speed, it is not commonly used because it is more prone to memory issues and the complexity of writing code. So then what ?

The second level of abstraction provides us with **high-level programming languages** (like example: Rust,C and GO). These languages are more human-readable than assembly language, featuring syntactic sugar that hides much of the complexity and memory management from the programmer. With this, programmers can write programs with less complexity and fewer errors. Different languages handle memory allocation and deallocation in various ways; some manage it efficiently, while others do not, each with its own trade-offs. But wait a sec... haven't I just told you CPU cannot understand anything other then 0's and 1's(binary) ?.

We cannot execute high-level programming language programs directly on the CPU, we must convert these syntactic sugar programs into binary code. This translation is done by **compilers**. We will focus on how Rust code is converted to binary code and what internal checks occur during compilation, we will peel layer by layer and understand each and every stage. With this in mind, let's get started üòÑ.

## High-Level Overview of Compilation Layers
The code written by developers is human-readable, allowing others to easily read and understand it. However, a compiler cannot understand human-written code. We need to convert source code into binary code, which is the only format the CPU can understand.


Although there are several steps required to produce binary code, at a high level, these steps are divided into three main pillars **Frontend, Middle and Backend**.This breaks down the complex process of converting source code to machine code.

<img 
  width="1500px"
  height="560px" 
  src = "./images/compiler_three_pillers.png" 
/>
<br/>

At the frontend, you have Rust code. At the backend, you have the binary machine code generated by **LLVM(Low Level Virtual Machine)** that runs directly on the target machine. In the middle, all the Rust-specific ownership and borrowing checks happen.

We will peel back each layer and understand how Rust compilation works. If we zoom in a littel on rust compilation three pillars, this what we get as you can see in the below image.

<img 
  width="1500px"
  height="560px" 
  src = "./images/compiler_all_stages.png" 
/>
<br/>

I don't expect you to know all the terms shown in the picture above, but don't worry by the end of this blog, you will understand all of them. Let's go step by step, peeling back each layer to understand what happens while compiling our code.

Keeping this big picture in mind lets start peeling the Orange üçä.

### Layer One: Lexing,Parsing and AST:

Lets take an example as an source code:
```rust
fn main() {
    // Lets do some investigation :)
    let some = String::from("chinna");
    println!("Say my name:");
    println!("{}", some);

    time_pass(&some);
}

fn time_pass(pass: &String) {
    println!("Time passing with this guy: {}", pass);
}
```

This step is the frist one where compilation start's, the compile first reads the code `.rs` file as plain text then compiler break down this linear text into **Tokens** like `fn`,`some`,`{` this is called **Lexing**.

Then compiler converts these tokens into Tree like structure called AST(Abstract Syntax Tree) and this AST still still resembles a lot with the source code but it is in tree like structure this is known as **Parsing**. You can see the AST version of the code example that we have taken at [hear](https://github.com/baindlapranayraj/rektoff/blob/main/rektoff-office-hour/AST.txt).

<img src="./images/first_step.png" />

AST will captures all the syntactic code into tree like structure and Crucially, You may ask why do we need to do this ? 

Well, compilers cannot understand this linear source code directly. The source code is sugar-coated syntax designed for human readability, not for compilers. The Abstract Syntax Tree (AST) abstracts away certain details; it is a tree data structure that best represents the syntactic structure of the source code.



