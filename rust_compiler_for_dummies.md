<img 
  width="1500px"
 height="460px"
 src="./images/header_rust_compiler2.jpg"
/>


# Rust Compiler For Dummies


## Setting Up the stage: 
As you may already know, all programs that are written are ultimately converted into binary instructions (those fancy zeros and ones). Why? Because the CPU cannot understand our source code; all it understands is 0s and 1s. Since we cannot write or interact with the memory by writing 0's and 1's we have to created a some abstraction for writing the programmes in human readable fashion.

The thinnest abstraction layer for writing code to interact with memory is **Assembly**. It is a low-level language that helps us write human-readable code, operates directly with memory, and provides fine-grained control over computer operations.
Although Assembly offers high efficiency and speed, it is not commonly used because it is more prone to memory issues and the complexity of writing code. So then what ?

The second level of abstraction provides us with **high-level programming languages** (like example: Rust,C and GO). These languages are more human-readable than assembly language, featuring syntactic sugar that hides much of the complexity and memory management from the programmer. With this, programmers can write programs with less complexity and fewer errors. Different languages handle memory allocation and deallocation in various ways; some manage it efficiently, while others do not, each with its own trade-offs. But wait a sec... haven't I just told you CPU cannot understand anything other then 0's and 1's(binary) ?.

We cannot execute high-level programming language programs directly on the CPU, we must convert these syntactic sugar programs into binary code. This translation is done by **compilers**. We will focus on how Rust code is converted to binary code and what internal checks occur during compilation, we will peel layer by layer and understand each and every stage. With this in mind, let's get started ðŸ˜„.

## Highe level Overview of Compilation layers: 
The code written by developers is human-readable, allowing others to easily read and understand it. However, a compiler cannot understand human-written code. We need to convert source code into binary code, which is the only format the CPU can understand.


Although there are several steps required to produce binary code, at a high level, these steps are divided into three main pillars **Frontend, Middle and Backend**.

<img 
  width="1500px"
  height="560px" 
  src = "./images/compiler_three_pillers.png" 
/>
<br/>

At the frontend, you have Rust code. At the backend, you have the binary machine code generated by **LLVM(Low Level Virtual Machine)** that runs directly on the target machine. In the middle, all the Rust-specific ownership and borrowing checks happen.

We will peel back each layer and understand how Rust compilation works. If we zoom in a littel on rust compilation stages, this what we get as you can see in the below image.

<img 
  width="1500px"
  height="560px" 
  src = "./images/compiler_all_stages.png" 
/>
<br/>



